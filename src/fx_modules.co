define "fx_modules", ["module_base", "utils", "contextfx", "datafx", "displace"], !(mb, utils, cfx, dfx, dsp) ->
	{rand, randint, mmod} = utils

	mb.Module "ycbcrPre", [
		mb.Bool "enable"
	], !(settings, context, data) ->
		if settings.enable then dfx.toYCbCr(data)

	mb.Module "ycbcrPost", [
		mb.Bool "enable"
	], !(settings, context, data) ->
		if settings.enable then dfx.fromYCbCr(data)

	mb.Module "leaks", [
		mb.Num "probability"
		mb.Num "strength"
		mb.Int "nMin", {min: 0, max: 20}
		mb.Int "nMax", {min: 0, max: 20}
		mb.Int "magic1", {min: -10, max: 10}
		mb.Int "magic2", {min: -10, max: 10}
	], !(settings, context, data) ->
		return if rand() > settings.probability
		for x from 0 til randint(settings.nMin, settings.nMax)
			dfx.leak(data, settings.strength, settings.magic1, settings.magic2)

	mb.Module "sliceglitch", [
		mb.Num "probability"
		mb.Int "nMin", {min: 0, max: 100, value: 5}
		mb.Int "nMax", {min: 0, max: 100, value: 5}
		mb.Bool "randChan", {value: true}
		mb.Bool "chanR", {value: true}
		mb.Bool "chanG", {value: true}
		mb.Bool "chanB", {value: true}
		mb.Int "hMin", {min: 1, max: 300, value: 5}
		mb.Int "hMax", {min: 1, max: 300, value: 23}
		mb.Int "offMin", {min: 0, max: 100, value: 5}
		mb.Int "offMax", {min: 0, max: 100, value: 25}
		mb.Int "driftProb", {min: 0, max: 100, value: 20}
		mb.Int "driftMag", {min: -10, max: 10, value: 2}
	], !(settings, context, data) ->
		return if rand() > settings.probability

		for x from 0 til randint(settings.nMin, settings.nMax)
			chanmask = 0
			if not settings.randChan or randint(0, 100) < 33 then chanmask |= (+settings.chanR)
			if not settings.randChan or randint(0, 100) < 33 then chanmask |= (+settings.chanG) << 1
			if not settings.randChan or randint(0, 100) < 33 then chanmask |= (+settings.chanB) << 2
			drift = (if randint(0, 100) < settings.driftProb then settings.driftMag else 0)
			dfx.sliceglitch(data, settings.hMin, settings.hMax, settings.offMin, settings.offMax, chanmask, 1, drift)

	mb.Module "noise", [
		mb.Num "probability"
		mb.Int "nMin", {min: 0, max: 100, value: 5}
		mb.Int "nMax", {min: 0, max: 100, value: 5}
		mb.Int "hMin", {min: 0, max: 100, value: 5}
		mb.Int "hMax", {min: 0, max: 100, value: 5}
		mb.Int "noisiness", {min: 0, max: 100, value: 35}
		mb.Int "brightnessMin", {min: -100, max: 100, value: 10}
		mb.Int "brightnessMax", {min: -100, max: 100, value: 50}
		mb.Bool "replace"
	], !(settings, context, data) ->
		return if rand() > settings.probability
		for x from 0 til randint(settings.nMin, settings.nMax)
			h = randint(settings.hMin, settings.hMax)
			y0 = randint(0, data.height - h)
			y1 = y0 + h
			dfx.noise(data, y0, y1,
				settings.noisiness,
				settings.brightnessMin,
				settings.brightnessMax,
				settings.replace
			)

	mb.Module "bitbang", [
		mb.Num "probability"
		mb.Int "minStrideIn", {min: 0, max: 32}
		mb.Int "maxStrideIn", {min: 0, max: 32}
		mb.Int "minStrideOut", {min: 0, max: 32}
		mb.Int "maxStrideOut", {min: 0, max: 32}
		mb.Int "minFeedback", {min: 0, max: 10}
		mb.Int "maxFeedback", {min: 0, max: 10}
		mb.Int "minYDrift", {min: -2, max: 10}
		mb.Int "maxYDrift", {min: -2, max: 10}
		mb.Int "offScale", {min: 0, max: 100}
	], !(settings, context, data) ->
		return if rand() > settings.probability
		bitbangSourceData = {data.width, data.height, data: new Uint8ClampedArray(data.data)}
		dfx.bitbang(data, bitbangSourceData,
			settings.offScale,
			settings.minStrideIn,   settings.maxStrideIn,
			settings.minStrideOut,  settings.maxStrideOut,
			settings.minFeedback,   settings.maxFeedback
			settings.minYDrift,     settings.maxYDrift
		)

	mb.Module "bloom", [
		mb.Num "strength"
		mb.Int "radius", {min: 0, max: 10}
		mb.Num "counter"
	], !(settings, context, data) ->
		if settings.radius > 0 and settings.strength > 0 then
			context.putImageData(data, 0, 0)
			cfx.bloom(context, settings.radius, settings.strength, settings.counter)
			data = context.get-image-data 0, 0, data.width, data.height
			return {data}

	mb.Module "tvsim", [
		mb.Bool "afterimageEnabled"
		mb.Num "afterimageStrengthOut"
		mb.Num "afterimageCounterOut"
		mb.Num "afterimageStrengthIn"
		mb.Num "scanlineStrength"
		mb.Num "tvscanStrength"
		mb.Num "tvscanSpeed"
		mb.Num "tvscanHeight"
		mb.Bool "displacementEnabled"
		mb.Num "displacementStrength", {min: -50, max: 50}
	], !(settings, context, data) ->
		if settings.afterimageEnabled
			cfx.afterImage(context, data, settings.afterimageStrengthOut, settings.afterimageCounterOut, settings.afterimageStrengthIn)

		if settings.tvscanStrength
			clock = +new Date()
			dfx.tvscan(data, clock, settings.tvscanSpeed, settings.tvscanStrength, settings.tvscanHeight)

		if settings.scanlineStrength
			dfx.scanlines data, 1.0 - settings.scanlineStrength

		if settings.displacementEnabled
			if not context.dismap
				context.dismap = dsp.createTVDisplacement()
			data = dfx.displacementMapper(data, context.dismap, settings.displacementStrength, settings.displacementStrength)

	return {}
