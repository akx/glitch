define "datafx", ["./utils"], (utils) ->
	{lerper, lerp, randint, birandint, zwrap, rand, mmod, zclamp} = utils

	scanlines = !({data, width, height}, multiplier = 0.7) ->
		return if multiplier >= 1
		for y from 0 til height by 2
			for x from 0 til width
				offset = y * width * 4 + x * 4
				data[offset++] *= multiplier
				data[offset++] *= multiplier
				data[offset++] *= multiplier

	leak = !({data, width, height}, multiplier = 0.5, magic1 = 0, magic2 = 0) ->
		return if multiplier <= 0
		lerp = lerper(multiplier)
		dwidth = width * 4
		len = data.length
		for y from 0 til height
			yoffset = y * dwidth + magic1
			for offset from yoffset til yoffset + dwidth by 4
				src = offset + 4 + magic2
				if src >= 0 and src < len and offset >= 0 and offset < len
					data[offset] = lerp data[offset], data[src]

	bitbang = !(outputData, inputData, offScale, minStrideIn, maxStrideIn, minStrideOut, maxStrideOut, minFeedback, maxFeedback, minYDrift, maxYDrift) ->
		strideIn = randint(minStrideIn, maxStrideIn)
		strideOut = randint(minStrideOut, maxStrideOut)
		offIn = randint(-offScale, offScale)
		offOut = randint(-offScale, offScale)
		yDrift = randint(minYDrift, maxYDrift)
		feedback = randint(minFeedback, maxFeedback) / 20.0
		fblerp = lerper(feedback)

		#console.log strideIn, strideOut, offIn, offOut, yDrift, feedback

		inp = inputData.data
			inl = &length
		outp = outputData.data
			outl = &length
		width = outputData.width

		last = 0

		for i from 0 til outp.length
			ii = offIn + i * strideIn
			ii += (0 | (ii / width)) * yDrift
			ii = mmod(ii, inl)
			io = mmod(offOut + i * strideOut, outl)

			if feedback > 0 then
				last = outp[io] = 0 | fblerp(last, inp[ii])
			else
				outp[io] = inp[ii]


		for i from 0 til outp.length by 4
			outp[i+3] = 255


	sliceoffset = !({data, width, height}, y0, y1, offset, chanmask=2b111, blend=0.2, drift=0) ->
		return if not chanmask
		lerp = lerper(blend)
		if offset > 0 then
			x0 = 0
			x1 = width
			dir = +1
		else
			x0 = width - 1
			x1 = 0
			dir = -1

		for y from y0 til y1
			yoff = y * width * 4
			offset += drift
			for x from x0 til x1 by dir
				dst-offset = yoff + x * 4
				src-offset = yoff + zwrap(0 | (x + offset), width) * 4
				if chanmask & 1 then data[dst-offset] = lerp(data[dst-offset], data[src-offset])
				if chanmask & 2 then data[dst-offset+1] = lerp(data[dst-offset+1], data[src-offset+1])
				if chanmask & 4 then data[dst-offset+2] = lerp(data[dst-offset+2], data[src-offset+2])

	sliceglitch = !(data, shmin, shmax, offmin, offmax, chanmask, blend) ->
		sh = randint shmin, shmax
		y0 = randint 0, data.height - sh
		sliceoffset data, y0, y0 + sh, birandint(offmin, offmax), chanmask, blend


	noise = !({data, width}, y0, y1, noisiness, min-brightness, max-brightness, replace) ->
		noisiness /= 100
		if replace then
			minBrightness <?= 0
			maxBrightness >?= 255
		for y from y0 til y1
			yoff = y * width * 4
			for x from 0 til width
				if Math.random() < noisiness
					offset = yoff + x * 4
					brightness = randint(minBrightness, maxBrightness)
					if replace then
						data[offset++] = brightness
						data[offset++] = brightness
						data[offset++] = brightness
					else
						data[offset++] += brightness
						data[offset++] += brightness
						data[offset++] += brightness


	# Thanks to http://www.equasys.de/colorconversion.html

	to-ycbcr-matrix = [
	#	pre post 	red		green	blue
		0,	0,		 0.299,	 0.587,	0.114,
		0,	128,	-0.169,	-0.331,	0.500,
		0,	128,	 0.500,	-0.419,	0.081,
	]

	from-ycbcr-matrix = [
	#	pre post 	red		green	blue
		0,		0,	1,		 0,		 1.4,
		-128,	0,	1,		-0.343, -0.711,
		-128,	0,	1,		 1.765,	 0
	]

	matrixXform = !({data, width, height}, matrix) ->
		offset = 0
		[
			r-pre, r-post, r0, r1, r2,
			g-pre, g-post, g0, g1, g2,
			b-pre, b-post, b0, b1, b2,
		] = matrix

		for offset from 0 til data.length by 4
			r = data[offset] + r-pre
			g = data[offset+1] + g-pre
			b = data[offset+2] + b-pre
			data[offset] =   (r0 * r + r1 * g + r2 * b) + r-post
			data[offset+1] = (g0 * r + g1 * g + g2 * b) + g-post
			data[offset+2] = (b0 * r + b1 * g + b2 * b) + b-post

	toYCbCr = !(image-data) -> matrix-xform image-data, to-ycbcr-matrix
	fromYCbCr = !(image-data) -> matrix-xform image-data, from-ycbcr-matrix

	tvscan = !({data, width, height}, clock, speed, strength, heightPerc) ->
		mh = 0 | (height * heightPerc)
		y1 = mmod(clock * speed, height + mh)
		y0 = y1 - mh

		for y from 0 til height
			if y0 < y < y1 then
				b = Math.pow((y - y0) / mh, 2) * 255 * strength
				if b > 0 then
					off = y * width * 4
					for x from 0 til width
						data[off++] += b
						data[off++] += b
						data[off++] += b
						data[off++] += b


	displacementMapper = !(data, displacementMap, scaleX, scaleY) ->
		{width, height} = data

		document.createElement "canvas"
			& <<< {width, height}
			&getContext "2d"
				&drawImage(displacementMap, 0, 0, width, height)
				displacementData = &getImageData(0, 0, width, height).data

		sourceBuf = data.data
		destBuf = new Uint8ClampedArray(data.data)

		if scaleX != 0 or scaleY != 0 then
			for y from 0 til height
				yoff = y * width * 4
				for x from 0 til width
					offset = yoff + x * 4
					disZ = (displacementData[offset + 2]) / 127.0
					disX = (displacementData[offset] - 127) / 128.0 * scaleX * disZ
					disY = (displacementData[offset + 1] - 127) / 128.0 * scaleY * disZ

					sourceX = 0 | Math.round(x + disX)
					sourceY = 0 | Math.round(y + disY)
					sourceOffset = (zclamp(sourceY, height) * width * 4 + zclamp(sourceX, width) * 4)
					destBuf[offset++] = sourceBuf[sourceOffset++]
					destBuf[offset++] = sourceBuf[sourceOffset++]
					destBuf[offset++] = sourceBuf[sourceOffset++]

		sourceBuf.set(destBuf)

	return {
		scanlines
		leak
		bitbang
		sliceoffset
		sliceglitch
		noise
		matrixXform
		fromYCbCr
		toYCbCr
		tvscan
		displacementMapper
	}